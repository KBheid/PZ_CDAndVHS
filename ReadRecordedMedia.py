import uuid as uuid

# Chop the first few lines of the file, one is blank and one indicates the autogenerated nature of the file
linesToIgnore = 2

# Items in a content line that should be replaced
replacements = {
	"[img=music]": 'â™«'
}

# The types of items we're looking for, seemingly always suffixed with a : (which you should ignore when setting this variable)
typeValues = {
	"CD": ['Title', 'Album', 'Production'],
	"VHS": ['Title'],
	"Home VHS": ['Title']
}

# Convert our keys into a list
lookingFor = list(typeValues.keys())
lookingFor = [x + ':' for x in lookingFor]

# Try to open all of our wikiformat files, if they don't exist, throw an error
templateFiles = {}
try: 
	for key in typeValues.keys():
		f = open('Templates/' + key.replace(' ', '_') + '.wikiformat')
		templateFiles[key] = f.read()
		f.close()
	f = open('Templates/contentLine.wikiformat')
	templateFiles['contentLine'] = f.read()
	f.close()
	
except:
	print("Missing template file. Ensure that a file exists under Templates for each of the following items:", 
		[x.replace(' ', '_') + '.wikiformat' for x in list(typeValues.keys())],
		"and 'contentLine.wikiformat'"
	)

# Read our primary file - for each item, we will write a new file using the writeFile function
def readFile():
	print("Enter file location: >")
	fileLocation = input()
	
	try:
		openFile = open(fileLocation, "r")
	except OSError:
		print('Invalid file location:', fileLocation)
		readFile()
		return
	
	fileLines = openFile.readlines()
	fileLines = fileLines[linesToIgnore:]
	
	# Chop everything before the = and strip the quotes away.
	choppedLines = [chopLine(x) for x in fileLines]
	
	done = False
	currentLine = 0
	
	while not done:
		done, currentLine = readNextMedia(choppedLines, currentLine)
	
	openFile.close()
	

# Parse the next media found
def readNextMedia(lines, current):
	done = False
	
	# Get all type specific data:
	mediaType = lines[current].split(':')[0].strip()
	neededValues = typeValues[mediaType]
	values = {}
	mediaContent = []
	
	# Consume media type
	current += 1
	
	for neededValue in neededValues:
		values[neededValue] = lines[current]
		current += 1
	
	
	# Move until we reach a line that indicates a new entry or the end
	while not lines[current].startswith(tuple(lookingFor)) and not done:
		mediaContent.append(lines[current])
		
		current += 1
		if current >= len(lines):
			done = True
			break
		
	nextUUID = str(uuid.uuid4())
	fileName = 'media'+nextUUID if not 'Title' in values else values['Title']
	writeFile(fileName, mediaType, values, mediaContent)
	
	return done, current

# Write to our output file
def writeFile(fileName, type, values, content):
	fileName = fileName.replace('.', '').replace(' ', '_').replace('?', '').replace('/', '-')
	f = open("Output/" + fileName + ".wikioutput", 'w', encoding="utf-8")
	
	contentLineTemplate = templateFiles['contentLine']
	template = templateFiles[type]
	
	
	for key, val in values.items():
		toReplace = '%' + str(key).replace(' ', '_') + '%'
		template = template.replace(toReplace, val)
		
	contentLines = []
	for contentLine in content:
		newLine = contentLineTemplate.replace('%mediaContentItem%', contentLine)
		contentLines.append(newLine)
	
	contentLines = '\n'.join(contentLines)
	
	template = template.replace('%mediaContent%', contentLines)
	
	f.write(template)
	
	f.close()

# Chop a line - they are all prefixed with some GUID identifier for lua usage
def chopLine(line):
	for key, value in replacements.items():
		line = line.replace(key, value)

	retVal = line.split('=')[1]
	retVal = retVal.strip()
	retVal = retVal[1:-1]
	
	return retVal
	

readFile()